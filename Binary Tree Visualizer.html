<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <meta http-equiv="X-UA-Compatible" content="ie=edge" />
      <title>Binary Tree Visualizer | Interactive Tool (Enhanced)</title>
      <meta name="description"
         content="A simple and interactive binary tree visualizer to help you understand how binary trees work in programming and data structures." />
      <meta name="keywords"
         content="binary tree visualizer, data structures, programming, algorithms, JavaScript, coding tools, tree visualization" />
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" />
      <link rel="icon" href="https://pngup.com/0d0U/abdelhalim-yasser%20logo.png" sizes="512x512" type="image/png">
      <link rel="apple-touch-icon" href="https://pngup.com/0d0U/abdelhalim-yasser%20logo.png" sizes="180x180"
         type="image/png">
      <link rel="manifest" href="manifest.json">
      <meta name="theme-color" content="#2b2b2f">
      <meta name="mobile-web-app-capable" content="yes">
      <meta name="apple-mobile-web-app-capable" content="yes">
      <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
      <style>
         *,
         html {
         margin: 0;
         padding: 0;
         box-sizing: border-box;
         }
         body {
         font-family: Arial, sans-serif;
         text-align: center;
         background-color: #1A1A1D;
         margin: 0;
         padding: 20px;
         display: flex;
         flex-direction: column;
         min-height: 100vh;
         }
         main {
         flex: 1;
         display: flex;
         flex-direction: column;
         align-items: center;
         justify-content: center;
         }
         header {
         top: 0;
         z-index: 1000;
         width: 100%;
         display: flex;
         justify-content: space-between;
         align-items: center;
         padding: 10px 20px;
         background-color: #1A1A1D;
         margin-bottom: 10px;
         }
         header h1 {
         color: #fff;
         font-size: 24px;
         margin: 0;
         }
         header h1 a {
         color: #fff;
         text-decoration: none;
         }
         .hamburger {
         display: none;
         cursor: pointer;
         z-index: 1001;
         }
         .hamburger i {
         font-size: 24px;
         color: #fff;
         }
         .nav {
         display: flex;
         }
         .nav.open {
         display: block;
         }
         .nav-list {
         list-style: none;
         display: flex;
         gap: 25px;
         }
         .nav-link {
         text-decoration: none;
         color: #fff;
         font-size: 18px;
         font-weight: 500;
         transition: color 0.3s;
         }
         .nav-link:hover {
         color: #00BFFF;
         }
         @media (max-width: 767px) {
         .hamburger {
         display: flex;
         align-items: center;
         }
         .nav {
         position: fixed;
         top: 0;
         right: 0;
         height: 100vh;
         width: 70vw;
         background-color: #1A1A1D;
         transform: translateX(100%);
         transition: transform 0.2s ease-in-out;
         padding-top: 80px;
         z-index: 999;
         }
         .nav.open {
         transform: translateX(0);
         }
         .nav-list {
         flex-direction: column;
         gap: 30px;
         align-items: center;
         }
         }
         h1 {
         margin-bottom: 10px;
         color: #fff;
         }
         .subtitle {
         color: #bbb;
         margin-bottom: 20px;
         }
         .controls {
         margin-bottom: 20px;
         }
         .btn-group {
         margin-top: 10px;
         }
         input[type="number"] {
         padding: 10px;
         margin: 5px;
         font-size: 16px;
         width: 185px;
         border: 2px solid #666;
         border-radius: 8px;
         background-color: #2a2a2e;
         color: white;
         text-align: center;
         transition: all 0.3s ease;
         }
         input[type="number"]:focus {
         border-color: #00BFFF;
         outline: none;
         }
         button {
         padding: 10px 15px;
         font-size: 15px;
         margin: 5px;
         cursor: pointer;
         background: linear-gradient(159deg, rgba(0,0,128,1) 0%, rgba(0,191,255,1) 100%);
         color: white;
         border: none;
         border-radius: 8px;
         transition: all 0.3s ease;
         }
         button:hover {
         background: linear-gradient(159deg, rgba(0,191,255,1) 0%, rgba(0,0,128,1) 100%);
         transform: translateY(-2px);
         }
         .tree-container {
         display: block;
         align-items: center;
         justify-content: center;
         min-height: 500px;
         width: 90%;
         max-width: 1400px;
         margin: 0 auto 20px;
         border: 2px solid #00BFFF;
         border-radius: 12px;
         padding: 40px;
         background-color: #2b2b2f;
         box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
         overflow: auto;
         position: relative;
         }
         .canvas-inner {
         position: relative;
         height: 100%;
         }
         .tree-node {
         position: absolute;
         width: 60px;
         height: 60px;
         display: flex;
         align-items: center;
         justify-content: center;
         background: linear-gradient(159deg, rgba(0,0,128,1) 0%, rgba(0,191,255,1) 100%);
         color: white;
         border-radius: 50%;
         font-weight: bold;
         font-size: 16px;
         box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
         transition: all 0.3s ease;
         cursor: pointer;
         border: 2px solid #ffffff33;
         transform: translate(-50%, -50%); /* center by position */
         z-index: 10;
         }
         .tree-node:hover {
         transform: translate(-50%, -50%) scale(1.15);
         box-shadow: 0 4px 20px rgba(0, 191, 255, 0.6);
         }
         .tree-edge {
         position: absolute;
         height: 4px;
         border-radius: 2px;
         transform-origin: 0 50%;
         z-index: 1;
         transition: all 0.3s ease;
         box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
         }
         
         /* Dynamic colored edges based on connection type */
         .tree-edge.left-child {
         background: linear-gradient(90deg, #ff6b6b, #ff8e53);
         box-shadow: 0 2px 8px rgba(255, 107, 107, 0.4);
         }
         
         .tree-edge.right-child {
         background: linear-gradient(90deg, #4ecdc4, #44a08d);
         box-shadow: 0 2px 8px rgba(78, 205, 196, 0.4);
         }
         
         /* Hover effect for edges */
         .tree-edge:hover {
         height: 6px;
         transform-origin: 0 50%;
         }
         
         .root-label {
         position: absolute;
         top: -28px;
         left: 50%;
         transform: translateX(-50%);
         background: linear-gradient(159deg, rgba(0,0,128,1) 0%, rgba(0,191,255,1) 100%);
         color: white;
         padding: 4px 8px;
         border-radius: 12px;
         font-size: 11px;
         font-weight: bold;
         border: 1px solid #ffffff33;
         }
         .list-stats-wrapper {
         display: flex;
         gap: 20px;
         justify-content: center;
         align-items: flex-start;
         margin-bottom: 20px;
         flex-wrap: wrap;
         }
         @media (max-width: 767px) {
         .list-stats-wrapper {
         flex-direction: column;
         align-items: center;
         }
         }
         .stats {
         background: #2b2b2f;
         padding: 15px;
         width: 250px;
         margin-left: auto;
         margin-right: auto;
         text-align: left;
         border-radius: 8px;
         border: 2px solid #00BFFF;
         box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
         color: white;
         margin-top: 0;
         flex: 1;
         }
         .learn-more {
         background-color: #2b2b2f;
         padding: 15px;
         border-radius: 8px;
         width: 250px;
         margin: auto;
         border: 2px solid #00BFFF;
         box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
         margin-bottom: 60px;
         margin-top: 0;
         flex: 1;
         }
         .learn-more h2 {
         color: #00BFFF;
         }
         .learn-more p {
         color: #bbb;
         margin: 10px 0;
         }
         .overlay {
         display: none;
         position: fixed;
         top: 0;
         left: 0;
         width: 100%;
         height: 100%;
         background: rgba(0, 0, 0, 0.7);
         z-index: 2000;
         overflow: auto;
         }
         .popup {
         background: linear-gradient(159deg, rgba(0,0,128,1) 0%, rgba(0,191,255,1) 100%);
         padding: 25px;
         border-radius: 12px;
         max-width: 90%;
         width: 650px;
         margin: 80px auto;
         position: relative;
         box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
         color: white;
         font-size: 16px;
         text-align: left;
         line-height: 1.6;
         animation: fadeIn 0.4s ease;
         max-height: 80vh;
         overflow-y: auto;
         z-index: 2001;
         word-wrap: break-word; /* prevent long words overflow */
         white-space: normal;
         }
         .popup h2 {
         color: #fff;
         margin-bottom: 15px;
         text-align: center;
         }
         .popup p {
         color: #ddd;
         margin-bottom: 10px;
         }
         .popup ul {
         color: #ddd;
         margin-left: 20px;
         }
         .popup ul li {
         margin-bottom: 8px;
         }
         .close {
         position: absolute;
         right: 15px;
         top: 15px;
         font-size: 28px;
         cursor: pointer;
         color: #fff;
         }
         ::-webkit-scrollbar {
         width: 8px;
         }
         ::-webkit-scrollbar-track {
         background: #2b2b2f;
         }
         ::-webkit-scrollbar-thumb {
         background: #00BFFF;
         border-radius: 4px;
         }
         * {
         scrollbar-width: thin;
         scrollbar-color: #00BFFF #2b2b2f;
         }
         .container {
         overflow-x: auto;
         -webkit-overflow-scrolling: touch;
         }
         @keyframes fadeIn {
         from { opacity: 0; transform: scale(0.9); }
         to { opacity: 1; transform: scale(1); }
         }
         
         /* Edge color legend */
         .edge-legend {
         position: absolute;
         top: 10px;
         left: 10px;
         background: rgba(43, 43, 47, 0.9);
         padding: 10px;
         border-radius: 8px;
         border: 1px solid #00BFFF;
         color: white;
         font-size: 12px;
         z-index: 100;
         }
         
         .legend-item {
         display: flex;
         align-items: center;
         margin-bottom: 5px;
         }
         
         .legend-color {
         width: 20px;
         height: 3px;
         border-radius: 2px;
         margin-right: 8px;
         }
         
         .legend-color.left {
         background: linear-gradient(90deg, #ff6b6b, #ff8e53);
         }
         
         .legend-color.right {
         background: linear-gradient(90deg, #4ecdc4, #44a08d);
         }
         
         @media (max-width: 600px) {
         .popup {
         width: 85%;
         font-size: 14px;
         margin: 40px auto;
         padding: 20px;
         }
         .learn-more {
         width: 80%;
         }
         .tree-container {
         min-height: 400px;
         padding: 20px;
         }
         .tree-node {
         width: 50px;
         height: 50px;
         font-size: 14px;
         }
         .edge-legend {
         font-size: 10px;
         padding: 8px;
         }
         }
      </style>
   </head>
   <body>
      <header>
         <h1><a href="#">Binary Tree Visualizer</a></h1>
         <div class="hamburger" onclick="toggleMenu()">
            <i id="menu-icon" class="fas fa-bars"></i>
         </div>
         <nav class="nav" id="nav">
            <ul class="nav-list" id="nav-list">
               <li>
                  <a href="#" class="nav-link" onclick="openHelp()">How to work</a>
               </li>
               <li>
                  <a href="https://github.com/abdelhalimyasser/Data-Structures/tree/main/Tree" class="nav-link">View Implementation</a>
               </li>
               <li>
                  <a href="https://github.com/abdelhalimyasser" class="nav-link">Github</a>
               </li>
               <li>
                  <a href="https://www.linkedin.com/in/abdelhalimyasser/" class="nav-link">LinkedIn</a>
               </li>
            </ul>
         </nav>
      </header>
      <main>
         <h1 style="color: #00BFFF;">Binary Tree Visualizer</h1>
         <p class="subtitle">
            A simple binary tree visualizer to help you understand how binary trees work.
         </p>
         <div id="helpOverlay" class="overlay">
            <div class="popup">
               <span class="close" onclick="closeHelp()"><i class="fas fa-times"></i></span>
               <h2>How Binary Tree Works</h2>
               <p>
                  <b>Binary Tree:</b> A hierarchical data structure where each node has at most two children,
                  referred to as left and right child.
               </p>
               <ul>
                  <li>
                     <b>insert(value)</b> - Add a new node to the tree following BST rules.
                  </li>
                  <li>
                     <b>delete(value)</b> - Remove a node from the tree.
                  </li>
                  <li>
                     <b>search(value)</b> - Find if value exists in the tree.
                  </li>
                  <li><b>inOrder()</b> - Traverse: Left → Root → Right.</li>
                  <li><b>preOrder()</b> - Traverse: Root → Left → Right.</li>
                  <li><b>postOrder()</b> - Traverse: Left → Right → Root.</li>
                  <li><b>levelOrder()</b> - Traverse level by level (BFS).</li>
                  <li><b>getHeight()</b> - Get the height of the tree.</li>
                  <li><b>getSize()</b> - Get the number of nodes in the tree.</li>
                  <li><b>getMin()</b> - Find the minimum value in the tree.</li>
                  <li><b>getMax()</b> - Find the maximum value in the tree.</li>
                  <li><b>clear()</b> - Remove all nodes from the tree.</li>
               </ul>
               <p><b>Edge Colors:</b></p>
               <ul>
                  <li><b>Left children:</b> Red to orange gradient (#ff6b6b to #ff8e53)</li>
                  <li><b>Right children:</b> Teal to green gradient (#4ecdc4 to #44a08d)</li>
               </ul>
            </div>
         </div>
         <div class="controls">
            <input type="number" id="tree-input" placeholder="Enter a number" />
            <div class="btn-group">
               <button onclick="insertNode()">Insert</button>
               <button onclick="deleteNode()">Delete</button>
               <button onclick="searchNode()">Search</button>
               <button onclick="inOrderTraversal()">In-Order</button>
               <button onclick="preOrderTraversal()">Pre-Order</button>
               <button onclick="postOrderTraversal()">Post-Order</button>
               <button onclick="levelOrderTraversal()">Level-Order</button>
               <button onclick="findMin()">Find Min</button>
               <button onclick="findMax()">Find Max</button>
               <button onclick="getTreeHeight()">Get Height</button>
               <button onclick="clearTree()">Clear</button>
            </div>
         </div>
         <div id="tree-container" class="tree-container">
            <div class="edge-legend">
               <div class="legend-item">
                  <div class="legend-color left"></div>
                  <span>Left Child</span>
               </div>
               <div class="legend-item">
                  <div class="legend-color right"></div>
                  <span>Right Child</span>
               </div>
            </div>
            <div id="canvasInner" class="canvas-inner"></div>
         </div>
         <div class="list-stats-wrapper">
            <div class="stats" id="stats">
               <strong>Root:</strong> <span id="root">-</span><br />
               <strong>Size:</strong> <span id="size">0</span><br />
               <strong>Height:</strong> <span id="height">0</span><br />
               <strong>Is Empty:</strong> <span id="isEmpty">Yes</span><br />
               <strong>Min Value:</strong> <span id="minVal">-</span><br />
               <strong>Max Value:</strong> <span id="maxVal">-</span><br />
               <strong>Is Balanced:</strong> <span id="balanced">-</span><br />
            </div>
            <div class="learn-more" id="learn-more">
               <h2>Learn More Data Structures</h2>
               <div class="controls">
                  <button onclick="window.open('Stack Visualizer.html', '_blank')">Stack</button>
                  <button onclick="window.open('Queue Visualizer.html', '_blank')">Queue</button>
                  <button onclick="window.open('Linked List Visualizer.html', '_blank')">Linked List</button>
               </div>
            </div>
         </div>
      </main>
      <footer>
         <p style="color: #fff">
            Created by
            <a href="#" target="_blank"
               style="color: #00BFFF; text-decoration: none">
            Abdelhalim Yasser</a>
         </p>
         <p style="color: #fff">
            <a href="#" style="color: #fff; text-decoration: none">Binary Tree Visualizer</a>
            © 2025
         </p>
      </footer>
      <script>
         // Toggle menu for mobile view
         let menuOpen = false;
         function toggleMenu() {
             const nav = document.getElementById("nav");
             const icon = document.getElementById("menu-icon");
             menuOpen = !menuOpen;
             if (menuOpen) {
                 nav.classList.add("open");
                 icon.classList.replace("fa-bars", "fa-times");
             } else {
                 nav.classList.remove("open");
                 icon.classList.replace("fa-times", "fa-bars");
             }
         }
         document.querySelectorAll("#nav a").forEach(link => {
             link.addEventListener("click", () => {
                 const nav = document.getElementById("nav");
                 const icon = document.getElementById("menu-icon");
                 nav.classList.remove("open");
                 if (icon.classList.contains('fa-times')) icon.classList.replace("fa-times", "fa-bars");
                 menuOpen = false;
             });
         });

         // Binary Tree Implementation
         class TreeNode {
             constructor(data) {
                 this.data = data;
                 this.left = null;
                 this.right = null;
             }
         }
         class BinarySearchTree {
             constructor() {
                 this.root = null;
             }
             insert(data) {
                 const newNode = new TreeNode(data);
                 if (!this.root) {
                     this.root = newNode;
                     return;
                 }
                 this.insertNode(this.root, newNode);
             }
             insertNode(node, newNode) {
                 if (newNode.data < node.data) {
                     if (!node.left) {
                         node.left = newNode;
                     } else {
                         this.insertNode(node.left, newNode);
                     }
                 } else if (newNode.data > node.data) {
                     if (!node.right) {
                         node.right = newNode;
                     } else {
                         this.insertNode(node.right, newNode);
                     }
                 }
                 // equal values are ignored (no duplicates)
             }
             delete(data) {
                 this.root = this.deleteNode(this.root, data);
             }
             deleteNode(node, data) {
                 if (!node) return null;
                 if (data < node.data) {
                     node.left = this.deleteNode(node.left, data);
                 } else if (data > node.data) {
                     node.right = this.deleteNode(node.right, data);
                 } else {
                     if (!node.left && !node.right) {
                         return null;
                     }
                     if (!node.left) {
                         return node.right;
                     }
                     if (!node.right) {
                         return node.left;
                     }
                     const minRight = this.findMin(node.right);
                     node.data = minRight.data;
                     node.right = this.deleteNode(node.right, minRight.data);
                 }
                 return node;
             }
             search(data) {
                 return this.searchNode(this.root, data);
             }
             searchNode(node, data) {
                 if (!node) return false;
                 if (data === node.data) return true;
                 if (data < node.data) return this.searchNode(node.left, data);
                 return this.searchNode(node.right, data);
             }
             inOrder() {
                 const result = [];
                 this.inOrderHelper(this.root, result);
                 return result;
             }
             inOrderHelper(node, result) {
                 if (node) {
                     this.inOrderHelper(node.left, result);
                     result.push(node.data);
                     this.inOrderHelper(node.right, result);
                 }
             }
             preOrder() {
                 const result = [];
                 this.preOrderHelper(this.root, result);
                 return result;
             }
             preOrderHelper(node, result) {
                 if (node) {
                     result.push(node.data);
                     this.preOrderHelper(node.left, result);
                     this.preOrderHelper(node.right, result);
                 }
             }
             postOrder() {
                 const result = [];
                 this.postOrderHelper(this.root, result);
                 return result;
             }
             postOrderHelper(node, result) {
                 if (node) {
                     this.postOrderHelper(node.left, result);
                     this.postOrderHelper(node.right, result);
                     result.push(node.data);
                 }
             }
             levelOrder() {
                 if (!this.root) return [];
                 const result = [];
                 const queue = [this.root];
                 while (queue.length > 0) {
                     const node = queue.shift();
                     result.push(node.data);
                     if (node.left) queue.push(node.left);
                     if (node.right) queue.push(node.right);
                 }
                 return result;
             }
             getHeight() {
                 return this.getNodeHeight(this.root);
             }
             getNodeHeight(node) {
                 if (!node) return 0;
                 return 1 + Math.max(this.getNodeHeight(node.left), this.getNodeHeight(node.right));
             }
             getSize() {
                 return this.getSizeHelper(this.root);
             }
             getSizeHelper(node) {
                 if (!node) return 0;
                 return 1 + this.getSizeHelper(node.left) + this.getSizeHelper(node.right);
             }
             findMin(node = this.root) {
                 if (!node) return null;
                 while (node.left) {
                     node = node.left;
                 }
                 return node;
             }
             findMax(node = this.root) {
                 if (!node) return null;
                 while (node.right) {
                     node = node.right;
                 }
                 return node;
             }
             isBalanced() {
                 return this.checkBalance(this.root) !== -1;
             }
             checkBalance(node) {
                 if (!node) return 0;
                 const leftHeight = this.checkBalance(node.left);
                 if (leftHeight === -1) return -1;
                 const rightHeight = this.checkBalance(node.right);
                 if (rightHeight === -1) return -1;
                 if (Math.abs(leftHeight - rightHeight) > 1) return -1;
                 return Math.max(leftHeight, rightHeight) + 1;
             }
             clear() {
                 this.root = null;
             }
         }

         let binaryTree = new BinarySearchTree();

         function renderTree() {
             const container = document.getElementById("canvasInner");
             container.innerHTML = "";
             if (!binaryTree.root) {
                 const treeContainer = document.getElementById('tree-container');
                 treeContainer.querySelector('.canvas-inner').innerHTML = '<div style="color: #bbb; font-size: 18px; padding: 20px;">Empty Tree</div>';
                 updateStats();
                 return;
             }
             const positions = calculatePositions(binaryTree.root);
             // compute width and center offset
             const nodeSpacing = 140; // horizontal spacing between inorder nodes
             const nodeSize = 60;
             const totalNodes = positions.size;
             const contentWidth = Math.max(totalNodes * nodeSpacing, 600);
             container.style.width = contentWidth + 'px';

             // center inside outer container
             const outer = document.getElementById('tree-container');
             // scroll so that tree is centered
             setTimeout(() => {
                 outer.scrollLeft = Math.max(0, (container.offsetWidth - outer.clientWidth) / 2);
             }, 0);

             drawTree(container, binaryTree.root, positions);
             updateStats();
         }

         // Assign positions using inorder index to guarantee left-to-right ordering
         function calculatePositions(root) {
             const positions = new Map();
             const levelHeight = 120;
             const nodeSpacing = 140;
             let index = 0;

             function inorderAssign(node, depth) {
                 if (!node) return;
                 inorderAssign(node.left, depth + 1);
                 positions.set(node, { x: index * nodeSpacing, y: depth * levelHeight });
                 index++;
                 inorderAssign(node.right, depth + 1);
             }
             inorderAssign(root, 0);
             return positions;
         }

         function drawTree(container, root, positions) {
             // copy positions and compute offset to center the tree inside container
             const keys = Array.from(positions.keys());
             const xs = Array.from(positions.values()).map(p => p.x);
             const minX = Math.min(...xs);
             const maxX = Math.max(...xs);
             const padding = 80;
             const treeWidth = maxX - minX + padding * 2 + 60; // include node size
             // shift so leftmost x becomes padding
             const offsetX = padding - minX + 30; // additional centering

             // create edges first so they appear under nodes
             drawEdges(container, root, positions, offsetX);
             drawNodes(container, root, positions, offsetX);
         }

         function drawEdges(container, node, positions, offsetX) {
             if (!node) return;
             const nodeSize = 60;
             const pos = positions.get(node);
             const fromX = pos.x + offsetX;
             const fromY = pos.y + nodeSize / 2;

             if (node.left) {
                 const leftPos = positions.get(node.left);
                 const toX = leftPos.x + offsetX;
                 const toY = leftPos.y + nodeSize / 2;
                 createEdge(container, { x: fromX, y: fromY }, { x: toX, y: toY }, 'left-child');
                 drawEdges(container, node.left, positions, offsetX);
             }
             if (node.right) {
                 const rightPos = positions.get(node.right);
                 const toX = rightPos.x + offsetX;
                 const toY = rightPos.y + nodeSize / 2;
                 createEdge(container, { x: fromX, y: fromY }, { x: toX, y: toY }, 'right-child');
                 drawEdges(container, node.right, positions, offsetX);
             }
         }

         function drawNodes(container, node, positions, offsetX) {
             if (!node) return;
             const pos = positions.get(node);
             const nodeDiv = document.createElement('div');
             nodeDiv.className = 'tree-node';
             nodeDiv.style.left = (pos.x + offsetX) + 'px';
             nodeDiv.style.top = pos.y + 'px';
             nodeDiv.textContent = node.data;
             if (node === binaryTree.root) {
                 const label = document.createElement('div');
                 label.className = 'root-label';
                 label.textContent = 'Root';
                 nodeDiv.appendChild(label);
             }
             container.appendChild(nodeDiv);
             drawNodes(container, node.left, positions, offsetX);
             drawNodes(container, node.right, positions, offsetX);
         }

         function createEdge(container, from, to, className) {
             const edge = document.createElement('div');
             edge.className = `tree-edge ${className}`;
             const dx = to.x - from.x;
             const dy = to.y - from.y;
             const length = Math.sqrt(dx * dx + dy * dy);
             const angle = Math.atan2(dy, dx) * 180 / Math.PI;
             edge.style.width = length + 'px';
             edge.style.left = from.x + 'px';
             edge.style.top = from.y + 'px';
             edge.style.transform = `rotate(${angle}deg)`;
             container.appendChild(edge);
         }

         function updateStats() {
             document.getElementById('root').textContent = binaryTree.root ? binaryTree.root.data : '-';
             document.getElementById('size').textContent = binaryTree.getSize();
             document.getElementById('height').textContent = binaryTree.getHeight();
             document.getElementById('isEmpty').textContent = binaryTree.root ? 'No' : 'Yes';
             document.getElementById('minVal').textContent = binaryTree.findMin()?.data ?? '-';
             document.getElementById('maxVal').textContent = binaryTree.findMax()?.data ?? '-';
             document.getElementById('balanced').textContent = binaryTree.root ? (binaryTree.isBalanced() ? 'Yes' : 'No') : '-';
         }

         function openHelp() {
             document.getElementById('helpOverlay').style.display = 'block';
         }

         function closeHelp() {
             document.getElementById('helpOverlay').style.display = 'none';
         }

         function insertNode() {
             const input = document.getElementById('tree-input');
             const value = parseInt(input.value);
             if (!isNaN(value)) {
                 binaryTree.insert(value);
                 renderTree();
                 input.value = '';
             } else {
                 alert('Please enter a valid number');
             }
         }

         function deleteNode() {
             const input = document.getElementById('tree-input');
             const value = parseInt(input.value);
             if (!isNaN(value)) {
                 binaryTree.delete(value);
                 renderTree();
                 input.value = '';
             } else {
                 alert('Please enter a valid number');
             }
         }

         function searchNode() {
             const input = document.getElementById('tree-input');
             const value = parseInt(input.value);
             if (!isNaN(value)) {
                 const found = binaryTree.search(value);
                 alert(found ? `Value ${value} found in the tree` : `Value ${value} not found`);
                 input.value = '';
             } else {
                 alert('Please enter a valid number');
             }
         }

         function inOrderTraversal() {
             const result = binaryTree.inOrder();
             alert('In-Order Traversal: ' + (result.length ? result.join(', ') : 'Empty'));
         }

         function preOrderTraversal() {
             const result = binaryTree.preOrder();
             alert('Pre-Order Traversal: ' + (result.length ? result.join(', ') : 'Empty'));
         }

         function postOrderTraversal() {
             const result = binaryTree.postOrder();
             alert('Post-Order Traversal: ' + (result.length ? result.join(', ') : 'Empty'));
         }

         function levelOrderTraversal() {
             const result = binaryTree.levelOrder();
             alert('Level-Order Traversal: ' + (result.length ? result.join(', ') : 'Empty'));
         }

         function findMin() {
             const min = binaryTree.findMin();
             alert(min ? `Minimum value: ${min.data}` : 'Tree is empty');
         }

         function findMax() {
             const max = binaryTree.findMax();
             alert(max ? `Maximum value: ${max.data}` : 'Tree is empty');
         }

         function getTreeHeight() {
             const height = binaryTree.getHeight();
             alert(`Tree height: ${height}`);
         }

         function clearTree() {
             binaryTree.clear();
             renderTree();
         }
      </script>
   </body>
</html>
